"""Output Formatter for Markdown generation."""
import json
from datetime import datetime
from pathlib import Path
from typing import Dict, Optional
from telegram.helpers import escape_markdown
from config.settings import get_settings
from config.logging_config import log


class OutputFormatter:
    """Formats and saves generated prompts as Markdown files."""

    def __init__(self, output_dir: Optional[str] = None):
        """
        Initialize output formatter.

        Args:
            output_dir: Directory to save output files (default from settings)
        """
        settings = get_settings()
        self.output_dir = Path(output_dir or settings.output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
        log.info(f"OutputFormatter initialized with directory: {self.output_dir}")

    def format_markdown(
        self,
        prompt_data: Dict,
        platform_specifics: Optional[Dict] = None,
    ) -> str:
        """
        Format prompt data as Markdown.

        Args:
            prompt_data: Dictionary containing all prompt components
            platform_specifics: Platform-specific optimizations

        Returns:
            Formatted Markdown string
        """
        md_parts = []

        # Header
        md_parts.append("# MASTER PROMPT (Text-to-Video)\n")
        md_parts.append("**Prompt untuk RunwayML/Pika/Kling:**\n")
        md_parts.append(f'"{prompt_data.get("master_prompt", "N/A")}"\n')
        md_parts.append("\n---\n")

        # Visual Specifications
        if "visual_specifications" in prompt_data:
            md_parts.append("# VISUAL SPECIFICATIONS\n")
            specs = prompt_data["visual_specifications"]

            md_parts.append("| Element | Value |")
            md_parts.append("|---------|-------|")

            for key, value in specs.items():
                md_parts.append(f"| {key} | {value} |")

            md_parts.append("\n---\n")

        # Script
        if "script" in prompt_data:
            md_parts.append("# SCRIPT\n")
            script = prompt_data["script"]

            if "hook" in script and script["hook"] != "N/A":
                escaped_hook = escape_markdown(script['hook'])
                md_parts.append("## Hook [0:00-0:03]")
                md_parts.append(f'*"{escaped_hook}"*')
                md_parts.append("")

            if "body" in script and script["body"] != "N/A":
                escaped_body = escape_markdown(script['body'])
                md_parts.append("## Body [0:03-0:45]")
                md_parts.append(escaped_body)
                md_parts.append("")

            if "cta" in script and script["cta"] != "N/A":
                escaped_cta = escape_markdown(script['cta'])
                md_parts.append("## CTA [0:45-0:60]")
                md_parts.append(f'*"{escaped_cta}"*')
                md_parts.append("")

            md_parts.append("---\n")

        # Platform Optimization
        if platform_specifics:
            md_parts.append("# PLATFORM OPTIMIZATION\n")

            for platform, specs in platform_specifics.items():
                md_parts.append(f"**{platform.capitalize()}:**")
                md_parts.append(f"- Aspect Ratio: {specs['aspect_ratio']}")
                md_parts.append(f"- Characteristics: {specs['characteristics']}")
                md_parts.append(f"- Optimal Length: {specs['optimal_length']}")
                md_parts.append(f"- Caption: {specs.get('caption_style', 'N/A')}")
                md_parts.append(f"- Editing Tips: {specs.get('editing_tips', 'N/A')}")
                md_parts.append("")

            md_parts.append("---\n")

        # Hashtags
        if "hashtags" in prompt_data:
            md_parts.append("# HASHTAGS\n")
            hashtags = prompt_data["hashtags"]

            # Join hashtags into a single string
            hashtag_string = " ".join(f"#{tag}" for tag in hashtags)
            md_parts.append(hashtag_string)
            md_parts.append("")

        # Footer
        md_parts.append("\n---")
        md_parts.append(f"\n*Generated by RekaKata - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*")

        return "\n".join(md_parts)

    def format_telegram_message(
        self,
        prompt_data: Dict,
        platform_specifics: Optional[Dict] = None,
    ) -> str:
        """
        Format prompt data for Telegram message.

        Args:
            prompt_data: Dictionary containing all prompt components
            platform_specifics: Platform-specific optimizations

        Returns:
            Formatted Telegram message (Markdown compatible)
        """
        message_parts = []

        # Header
        message_parts.append("ðŸŽ¬ *MASTER PROMPT (Text-to-Video)*")
        message_parts.append(f'`{prompt_data.get("master_prompt", "N/A")}`')
        message_parts.append("")

        # Visual Specifications
        if "visual_specifications" in prompt_data:
            message_parts.append("ðŸ“Š *VISUAL SPECIFICATIONS*")

            specs = prompt_data["visual_specifications"]
            for key, value in list(specs.items())[:5]:  # Limit to 5 items
                message_parts.append(f"â€¢ *{key}*: {value}")

            message_parts.append("")

        # Script
        if "script" in prompt_data:
            message_parts.append("ðŸ“ *SCRIPT*")

            script = prompt_data["script"]

            if "hook" in script and script["hook"] != "N/A":
                escaped_hook = escape_markdown(script['hook'])
                message_parts.append(f"ðŸŽ£ Hook: `{escaped_hook}`")

            if "body" in script and script["body"] != "N/A":
                escaped_body = escape_markdown(script['body'])
                message_parts.append(f"ðŸ“– Body: `{escaped_body}`")

            if "cta" in script and script["cta"] != "N/A":
                escaped_cta = escape_markdown(script['cta'])
                message_parts.append(f"ðŸ“¢ CTA: `{escaped_cta}`")

            message_parts.append("")

        # Platform Tips
        if platform_specifics:
            message_parts.append("ðŸ“± *PLATFORM TIPS*")

            # Show top 2 platforms
            for i, (platform, specs) in enumerate(list(platform_specifics.items())[:2]):
                message_parts.append(f"\n*{platform.capitalize()}*:")
                message_parts.append(f"â€¢ Ratio: {specs['aspect_ratio']}")
                message_parts.append(f"â€¢ Length: {specs['optimal_length']}")

            message_parts.append("")

        # Hashtags (limited)
        if "hashtags" in prompt_data:
            hashtags = prompt_data["hashtags"][:10]  # Limit to 10 hashtags
            hashtag_string = " ".join(f"#{tag}" for tag in hashtags)
            message_parts.append(f"ðŸ”– {hashtag_string}")
            message_parts.append("")

        # Footer
        message_parts.append("\nâœ¨ Generated by RekaKata")

        return "\n".join(message_parts)

    def save_markdown(
        self,
        markdown_content: str,
        filename: Optional[str] = None,
    ) -> str:
        """
        Save Markdown content to file.

        Args:
            markdown_content: Formatted Markdown string
            filename: Custom filename (default auto-generated)

        Returns:
            Path to saved file
        """
        if filename is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"prompt_{timestamp}.md"

        filepath = self.output_dir / filename

        with open(filepath, "w", encoding="utf-8") as f:
            f.write(markdown_content)

        log.info(f"Saved Markdown file: {filepath}")
        return str(filepath)

    def save_json(
        self,
        data: Dict,
        filename: Optional[str] = None,
    ) -> str:
        """
        Save data as JSON file.

        Args:
            data: Dictionary to save
            filename: Custom filename (default auto-generated)

        Returns:
            Path to saved file
        """
        if filename is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"prompt_{timestamp}.json"

        filepath = self.output_dir / filename

        with open(filepath, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2, ensure_ascii=False)

        log.info(f"Saved JSON file: {filepath}")
        return str(filepath)

    def get_file_url(self, filepath: str) -> str:
        """
        Get URL or path for file sharing.

        Args:
            filepath: Path to file

        Returns:
            File path or URL (for web deployment)
        """
        # For local development, return absolute path
        # For web deployment, this would return a URL
        return str(Path(filepath).absolute())
